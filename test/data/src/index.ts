import { StandardMerkleTree } from "@openzeppelin/merkle-tree";
import prettier from "prettier";
import { defaultAbiCoder } from "@ethersproject/abi";
import { doubleHash } from "./no-sort";
import { NoSortMerkleTree } from "./no-sort";

const leafNumber = 47;
// each value must be an array because of the types used in StandardMerkleTree
const leaves = [
  ["0x1111111111111111111111111111111111111111"],
  ["0x2222222222222222222222222222222222222222"],
  ["0x3333333333333333333333333333333333333333"],
  ["0x4444444444444444444444444444444444444444"],
  ["0x5555555555555555555555555555555555555555"],
  ["0x6666666666666666666666666666666666666666"],
  ["0x7777777777777777777777777777777777777777"],
  ["0x8888888888888888888888888888888888888888"],
  ["0x9999999999999999999999999999999999999999"],
  ["0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"],
  ["0xBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"],
  ["0xCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC"],
  ["0xDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"],
  ["0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"],
  ["0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"],
  ["0x0000000000000000000000000000000000000000"],
  ["0x0000000000000000000000000000000000000001"],
  ["0x0000000000000000000000000000000000000002"],
  ["0x0000000000000000000000000000000000000003"],
  ["0x0000000000000000000000000000000000000004"],
  ["0x0000000000000000000000000000000000000005"],
  ["0x0000000000000000000000000000000000000006"],
  ["0x0000000000000000000000000000000000000007"],
  ["0x0000000000000000000000000000000000000008"],
  ["0x0000000000000000000000000000000000000009"],
  ["0x0000000000000000000000000000000000000010"],
  ["0x0000000000000000000000000000000000000011"],
  ["0x0000000000000000000000000000000000000012"],
  ["0x0000000000000000000000000000000000000013"],
  ["0x0000000000000000000000000000000000000014"],
  ["0x0000000000000000000000000000000000000015"],
  ["0x0000000000000000000000000000000000000016"],
  ["0x0000000000000000000000000000000000000017"],
  ["0x0000000000000000000000000000000000000018"],
  ["0x0000000000000000000000000000000000000019"],
  ["0x0000000000000000000000000000000000000020"],
  ["0x0000000000000000000000000000000000000021"],
  ["0x0000000000000000000000000000000000000022"],
  ["0x0000000000000000000000000000000000000023"],
  ["0x0000000000000000000000000000000000000024"],
  ["0x0000000000000000000000000000000000000025"],
  ["0x0000000000000000000000000000000000000026"],
  ["0x0000000000000000000000000000000000000027"],
  ["0x0000000000000000000000000000000000000028"],
  ["0x0000000000000000000000000000000000000029"],
  ["0x0000000000000000000000000000000000000030"],
  ["0x0000000000000000000000000000000000000031"],
  ["0x0000000000000000000000000000000000000032"],
  ["0x0000000000000000000000000000000000000033"],
  ["0x0000000000000000000000000000000000000034"],
  ["0x0000000000000000000000000000000000000035"],
  ["0x0000000000000000000000000000000000000036"],
  ["0x0000000000000000000000000000000000000037"],
  ["0x0000000000000000000000000000000000000038"],
  ["0x0000000000000000000000000000000000000039"],
  ["0x0000000000000000000000000000000000000040"],
  ["0x0000000000000000000000000000000000000041"],
  ["0x0000000000000000000000000000000000000042"],
  ["0x0000000000000000000000000000000000000043"],
  ["0x0000000000000000000000000000000000000044"],
  ["0x0000000000000000000000000000000000000045"],
  ["0x0000000000000000000000000000000000000046"],
  ["0x0000000000000000000000000000000000000047"],
  ["0x0000000000000000000000000000000000000048"],
  ["0x0000000000000000000000000000000000000049"],
  ["0x0000000000000000000000000000000000000050"],
  ["0x0000000000000000000000000000000000000051"],
  ["0x0000000000000000000000000000000000000052"],
  ["0x0000000000000000000000000000000000000053"],
  ["0x0000000000000000000000000000000000000054"],
  ["0x0000000000000000000000000000000000000055"],
  ["0x0000000000000000000000000000000000000056"],
  ["0x0000000000000000000000000000000000000057"],
  ["0x0000000000000000000000000000000000000058"],
  ["0x0000000000000000000000000000000000000059"],
  ["0x0000000000000000000000000000000000000060"],
  ["0x0000000000000000000000000000000000000061"],
  ["0x0000000000000000000000000000000000000062"],
  ["0x0000000000000000000000000000000000000063"],
  ["0x0000000000000000000000000000000000000064"],
  ["0x0000000000000000000000000000000000000065"],
  ["0x0000000000000000000000000000000000000066"],
  ["0x0000000000000000000000000000000000000067"],
  ["0x0000000000000000000000000000000000000068"],
  ["0x0000000000000000000000000000000000000069"],
  ["0x0000000000000000000000000000000000000070"],
  ["0x0000000000000000000000000000000000000071"],
  ["0x0000000000000000000000000000000000000072"],
  ["0x0000000000000000000000000000000000000073"],
  ["0x0000000000000000000000000000000000000074"],
  ["0x0000000000000000000000000000000000000075"],
  ["0x0000000000000000000000000000000000000076"],
  ["0x0000000000000000000000000000000000000077"],
  ["0x0000000000000000000000000000000000000078"],
  ["0x0000000000000000000000000000000000000079"],
  ["0x0000000000000000000000000000000000000080"],
  ["0x0000000000000000000000000000000000000081"],
  ["0x0000000000000000000000000000000000000082"],
  ["0x0000000000000000000000000000000000000083"],
  ["0x0000000000000000000000000000000000000084"],
  ["0x0000000000000000000000000000000000000085"],
];

console.log(`Proving leaf ${leafNumber} of ${leaves.length}\n`);

console.log("Standard Merkle tree:");
printTestData(StandardMerkleTree.of(leaves, ["bytes"]), leafNumber);
console.log("Unoptimised Merkle tree");
printTestData(NoSortMerkleTree.of(leaves, ["bytes"]), leafNumber);

function printTestData<T extends unknown[]>(
  tree: StandardMerkleTree<T>,
  leafIndex: number
) {
  console.log(`Root: ${tree.root}`);

  const treeData = tree.dump();
  const leaf = treeData.values.find((v) => v.value === leaves[leafIndex]);
  if (!leaf) {
    console.log("No matching leaf found");
    return;
  } else {
    const leafHash = {
      index: leaf.treeIndex,
      hash: treeData.tree[leaf.treeIndex] ?? "no hash found",
    };

    console.log(`Raw leaf: ${JSON.stringify(leaf.value)}`);
    const encodedLeaf = defaultAbiCoder.encode(["bytes"], leaf.value);
    console.log(`Encoded leaf: ${encodedLeaf}`);
    console.log(`Hashed leaf: ${doubleHash(encodedLeaf)}`);

    console.log(`Leaf: ${leafHash.index}) ${leafHash.hash.slice(2)}`);
  }

  const proof = tree.getProof(leafIndex);
  console.log(
    `Merkle Proof: ${prettier.format(
      JSON.stringify(proof.map((p) => p.slice(2))),
      {
        parser: "json",
      }
    )}`.trim()
  );

  console.log(
    `Hash sides (for unoptimised proof): ${JSON.stringify(
      hashSides(leaf.treeIndex, leaves.length)
    )}`
  );

  console.log(`Tree:\n${tree.render()}`.trim());

  // // Uncomment this to see the leaf hashes in original order
  // const leafHashes = treeData.values.map((v) => treeData.tree[v.treeIndex]);
  // console.log(
  //   `Leaves: ${prettier.format(JSON.stringify(leafHashes), {
  //     parser: "json",
  //   })}`.trim()
  // );

  // // Uncomment this to see the full StandardMerkleTree
  // console.log(
  //   `Tree dump: ${prettier.format(JSON.stringify(treeData), {
  //     parser: "json",
  //   })}`
  // );
}

function hashSides(index: number, width: number): boolean[] {
  const proofLength = Math.ceil(Math.log2(width));

  function parentIndex(i: number): number {
    return Math.floor((i - 1) / 2);
  }

  // indices of the accumulated hashes after they're combined with the proof hashes
  const indices = Array.from(Array(proofLength - 1).keys()).reduce(
    (acc, _) => acc.concat([parentIndex(acc[acc.length - 1]!)]),
    [index]
  );

  console.log(`indices: ${indices}`);

  // true when proof hash is on the left, so the accumulated hash is on the right
  // right children have an even index in the tree
  return indices.map((n) => n % 2 == 0);
}
